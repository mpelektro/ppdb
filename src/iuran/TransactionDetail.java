package iuran;import java.util.*;import java.sql.*;import kasir.*;import org.apache.commons.lang3.ObjectUtils;import org.apache.commons.lang3.StringUtils;import pelajar.Level;import sak.*;public abstract class TransactionDetail<TDetailType extends TransactionDetail, IuranType extends Iuran> extends KasirObject<TDetailType,TDetailType,Long> {    public static final String idColName = "ID", uuidColName = "UUID", idIuranColName = "IDIuran", idClerkColName = "IDClerk";    public static final String idTSummaryColName = "IDTransactionSummary", noIndukColName = "NomorInduk";    public static final String level1ColName = "Level1", amountColName = "Amount", paymentMethodColName = "PaymentMethod";    public static final String createDateColName = "CreateDate", lastUpdateDateColName = "LastUpdateDate", noteColName = "Note", settledColName = "Settled";    public static final String piutangColName = "Piutang";        public enum Tipe{IPSPTransaction, IPSTransaction, IUATransaction, IPSBTransaction, IPPTransaction, IUSTransaction, IUAPTransaction, OSISTransaction, IKSTransaction, PVTTransaction, SeragamTransaction, AttributeTransaction, PASBTransaction, BukuTransaction, SumbanganTransaction, ILLTransaction, TabunganTransaction, IDDTransaction, BeasiswaTransaction, BeasiswaCostTransaction, PiutangTransaction, CicilanHutangTransaction}    public enum PaymentMethod {CASH, TRANSFER, IDD, BEASISWA, BEASISWA_COST}        public long id;  //db-primary-key    public UUID uuid; //db-not-null-unique    public long idIuran;  // > 0    public int idClerk; //non-null    public long transactSummaryID;  //non-null    public String noIndukProfil;  //non-null    public Level.Level1 level1;    public float amount;  //non-null    public PaymentMethod paymentMethod;  //non-null    public Kalender createDate;  ////non-null    public Kalender lastUpdateDate;  ////non-null & updated    public String note;    public Boolean settled;    public Boolean piutang;        //create filter    protected TransactionDetail(UUID uuid, long iuranID, int clerkID, long tSummaryID, String noInduk, Level.Level1 lv1, float amount, PaymentMethod pm, Kalender cDate, Kalender luDate, String note, boolean settled, boolean piutang){        this.uuid = uuid;        idIuran = iuranID;        idClerk = clerkID;        transactSummaryID = tSummaryID;        noIndukProfil = noInduk;        level1 = lv1;        this.amount = amount;        paymentMethod = pm;        createDate = cDate;        lastUpdateDate = luDate;        this.note = note;        this.settled = settled;        this.piutang = piutang;    }        //create for insertion    protected TransactionDetail(UUID uuid, long iuranID, int clerkID, long tSummaryID, String noInduk, Level.Level1 lv1, float amount, PaymentMethod pm, String note, boolean piutang){        this(uuid, iuranID, clerkID, tSummaryID, noInduk, lv1, amount, pm, null, null, note, false, piutang);                Timestamp tstamp = new Timestamp(System.currentTimeMillis());        createDate = new Kalender(tstamp);        lastUpdateDate = new Kalender(tstamp);    }        //create from db    protected TransactionDetail(){}        protected TransactionDetail(TDetailType tDetail){        this(tDetail.uuid, tDetail.idIuran, tDetail.idClerk, tDetail.transactSummaryID, tDetail.noIndukProfil, tDetail.level1, tDetail.amount, tDetail.paymentMethod, tDetail.createDate, tDetail.lastUpdateDate, tDetail.note, tDetail.settled, tDetail.piutang);        id = tDetail.id;    }            public abstract Tipe getTipe();    public abstract Iuran.Tipe getTipeIuran();        public static String toStringHeader(){        String tmp = "Type|" + idColName + "|" + idIuranColName + "|" + idClerkColName + "|" + idTSummaryColName;        tmp += "|" + noIndukColName + "|" + level1ColName + "|" + amountColName + "|" + paymentMethodColName + "|" + createDateColName;        return tmp + "|" + lastUpdateDateColName + "|" + noteColName + "|" + settledColName + "|" + piutangColName;    }    public String toString(){        String tmp = getTipe() + "|" + id + "|" + idIuran + "|" + idClerk + "|" + transactSummaryID + "|" + noIndukProfil + "|" + level1;        return tmp + "|" + amount + "|" + paymentMethod + "|" + createDate + "|" + lastUpdateDate + "|" + note + "|" + settled + "|" + piutang;    }        public boolean equals(TDetailType tDetail){        if(tDetail != null){            boolean tmp = id == tDetail.id && idIuran == tDetail.idIuran && idClerk == idClerk && transactSummaryID == tDetail.transactSummaryID;            tmp = tmp && ObjectUtils.equals(noIndukProfil, tDetail.noIndukProfil) && ObjectUtils.equals(level1, tDetail.level1) && amount == tDetail.amount;            tmp = tmp && ObjectUtils.equals(paymentMethod, tDetail.paymentMethod) && ObjectUtils.equals(createDate, tDetail.createDate);            return tmp && ObjectUtils.equals(lastUpdateDate, tDetail.lastUpdateDate) && ObjectUtils.equals(note, tDetail.note) && settled == tDetail.settled && piutang == tDetail.piutang;        }        return false;    }            //====================================    /* true if all required fields (db-not-null fields) are valid */    public boolean isInsertDBValid(){        boolean tmp = idIuran > 0 && idClerk > 0 && transactSummaryID > 0 && noIndukProfil != null && !noIndukProfil.isEmpty();        return tmp && level1 != null && paymentMethod != null && createDate != null && lastUpdateDate != null && piutang != null;    }    public boolean isDBValid(){        return id > 0 && isInsertDBValid();    }            public Long getKey(){        return id;    }        public abstract TDetailType dynFromResultSet(ResultSet rs, boolean onCallingObj) throws SQLException, KasirException;    protected TDetailType dynFromResultSet(ResultSet rs) throws SQLException{        id = rs.getLong(idColName);        uuid = UUID.fromString(rs.getString(uuidColName));                idIuran = rs.getLong(idIuranColName);        idClerk = rs.getInt(idClerkColName);        transactSummaryID = rs.getLong(idTSummaryColName);        noIndukProfil = rs.getString(noIndukColName);                String lv1 = rs.getString(level1ColName);        for(Level.Level1 tmp : Level.Level1.values()){            if(tmp.toString().equalsIgnoreCase(lv1))                level1 = tmp;        }                amount = rs.getFloat(amountColName);                String payment = rs.getString(paymentMethodColName);        if (payment != null){            if(payment.equalsIgnoreCase("transfer"))                paymentMethod = PaymentMethod.TRANSFER;            else if(payment.equalsIgnoreCase("cash"))                paymentMethod = PaymentMethod.CASH;            else if(payment.equalsIgnoreCase("idd"))                paymentMethod = PaymentMethod.IDD;            else if(payment.equalsIgnoreCase("beasiswa"))                paymentMethod = PaymentMethod.BEASISWA;            else if(payment.equalsIgnoreCase("beasiswa_Cost"))                paymentMethod = PaymentMethod.BEASISWA_COST;            else                assert false;        }                createDate = Kalender.fromResultSet(rs, createDateColName);        lastUpdateDate = Kalender.fromResultSet(rs, lastUpdateDateColName);        note = rs.getString(noteColName);        settled = rs.getBoolean(settledColName);        piutang = rs.getBoolean(piutangColName);                return (TDetailType) this;    }        /* tipe must be non-null     * never ret null     */    public static <T extends TransactionDetail> T fromResultSet(ResultSet rs, Tipe tipe) throws SQLException, KasirException{        assert tipe != null : "fromResultSet(ResultSet, Tipe tipe = null)";                switch(tipe){            case IPSPTransaction:                return (T) new IPSPTransactionDetail().dynFromResultSet(rs, true);            case IPSTransaction:                return (T) new IPSTransactionDetail().dynFromResultSet(rs, true);            case IUATransaction:                return (T) new IUATransactionDetail().dynFromResultSet(rs, true);            case IPSBTransaction:                return (T) new IPSBTransactionDetail().dynFromResultSet(rs, true);            case IPPTransaction:                return (T) new IPPTransactionDetail().dynFromResultSet(rs, true);            case IUSTransaction:                return (T) new IUSTransactionDetail().dynFromResultSet(rs, true);            case IUAPTransaction:                return (T) new IUAPTransactionDetail().dynFromResultSet(rs, true);            case OSISTransaction:                return (T) new OSISTransactionDetail().dynFromResultSet(rs, true);            case IKSTransaction:                return (T) new IKSTransactionDetail().dynFromResultSet(rs, true);            case PVTTransaction:                return (T) new PVTTransactionDetail().dynFromResultSet(rs, true);            case SeragamTransaction:                return (T) new SeragamTransactionDetail().dynFromResultSet(rs, true);            case AttributeTransaction:                return (T) new AttributeTransactionDetail().dynFromResultSet(rs, true);            case PASBTransaction:                return (T) new PASBTransactionDetail().dynFromResultSet(rs, true);            case BukuTransaction:                return (T) new BukuTransactionDetail().dynFromResultSet(rs, true);            case SumbanganTransaction:                return (T) new SumbanganTransactionDetail().dynFromResultSet(rs, true);            case ILLTransaction:                return (T) new ILLTransactionDetail().dynFromResultSet(rs, true);            case TabunganTransaction:                return (T) new TabunganTransactionDetail().dynFromResultSet(rs, true);            case IDDTransaction:                return (T) new IDDTransactionDetail().dynFromResultSet(rs, true);            case BeasiswaTransaction:                return (T) new BeasiswaTransactionDetail().dynFromResultSet(rs, true);            case BeasiswaCostTransaction:                return (T) new BeasiswaCostTransactionDetail().dynFromResultSet(rs, true);            case CicilanHutangTransaction:                return (T) new CicilanHutangTransactionDetail().dynFromResultSet(rs, true);            default:                assert false : "the impossible";                System.out.println("fromResultSet method reached the impossible");                return null; //even more son of bitches impossible        }    }        /* tipe & colName may not be null     * never ret null     * throws KasirException(ROW_NOT_FOUND, key) if no matching row found     */    public static <T extends TransactionDetail> T fromResultSet(ResultSet rs, Tipe tipe, String colName, Number val) throws SQLException, KasirException{        assert tipe != null && colName != null;                if(DBSR.searchRow(rs, colName, val) > 0)            return fromResultSet(rs, tipe);        else            throw new KasirException(KasirException.Tipe.ROW_NOT_FOUND, val);    }    public static <T extends TransactionDetail> T fromResultSet(ResultSet rs, Tipe tipe, String colName, boolean caseSensitive, String key) throws SQLException, KasirException{        assert tipe != null && colName != null;                if(DBSR.searchRow(rs, colName, caseSensitive, key) > 0)            return fromResultSet(rs, tipe);        else            throw new KasirException(KasirException.Tipe.ROW_NOT_FOUND, key);    }            /* caller of this method must ensure that isDBValid = true & RS cursor points to the intended row     * never ret false     */    public boolean flushResultSet(ResultSet rs, boolean flushCreateDate) throws SQLException{        rs.updateString(uuidColName, uuid.toString());        rs.updateLong(idIuranColName, idIuran);        rs.updateInt(idClerkColName, idClerk);        rs.updateLong(idTSummaryColName, transactSummaryID);        rs.updateString(noIndukColName, noIndukProfil);        rs.updateString(level1ColName, level1.toString());        rs.updateFloat(amountColName, amount);        rs.updateString(paymentMethodColName, paymentMethod.toString());                if(flushCreateDate)            createDate.flushResultSet(rs, createDateColName);                lastUpdateDate = new Kalender(System.currentTimeMillis());        lastUpdateDate.flushResultSet(rs, lastUpdateDateColName);                rs.updateString(noteColName, note);        rs.updateBoolean(settledColName, settled);        rs.updateBoolean(piutangColName, piutang);                return true;    }    /* caller of this method must ensure that RS cursor is at the insert row & call rs.insertRow() when all done     * throws KasirException(DB_INVALID, this) if isInsertDBValid = false     * never ret false     */    public boolean insertResultSet(ResultSet rs) throws SQLException, KasirException{        if(isInsertDBValid())            return flushResultSet(rs, true);        else            throw new KasirException(KasirException.Tipe.DB_INVALID, this);    }        /* throws KasirException(DB_INVALID, this) if isDBValid = false     * throws KasirException(ROW_NOT_FOUND, this) if no row matches     * never ret false     */    public boolean updateResultSet(ResultSet rs) throws SQLException, KasirException{        if(!isDBValid())            throw new KasirException(KasirException.Tipe.DB_INVALID, this);                if(DBSR.searchRow(rs, idColName, id) > 0)            return flushResultSet(rs, false);        else            throw new KasirException(KasirException.Tipe.ROW_NOT_FOUND, this);    }        public String asWhereClause() {        LinkedList<String> whereClause = new LinkedList<>();                if (idIuran > 0)            whereClause.add(idIuranColName + " = '" + idIuran + "'");                if (idClerk > 0)            whereClause.add(idClerkColName + " = '" + idClerk + "'");                if (transactSummaryID > 0)            whereClause.add(idTSummaryColName + " = '" + transactSummaryID + "'");                if (noIndukProfil != null && !noIndukProfil.isEmpty())            whereClause.add(noIndukColName + " LIKE '%" + noIndukProfil + "%'");                if(level1 != null)            whereClause.add(level1ColName + " = '" + level1 + "'");                if (amount != 0)            whereClause.add(amountColName + " = '" + amount + "'");                if (paymentMethod != null)            whereClause.add(paymentMethodColName + " = '" + paymentMethod + "'");                if (createDate != null){            String wc = createDate.asWhereClause(false);            if(wc != null && !wc.isEmpty())                whereClause.add(createDateColName + " LIKE '%" + wc + "%'");        }                    if (lastUpdateDate != null){            String wc = lastUpdateDate.asWhereClause(false);            if(wc != null && !wc.isEmpty())                whereClause.add(lastUpdateDateColName + " LIKE '%" + wc + "%'");        }                if(settled != null)            whereClause.add(settledColName + " = " + (settled? "1" : "0"));                if(piutang != null)            whereClause.add(piutangColName + " = " + (piutang? "1" : "0"));        return whereClause.isEmpty()? "" : StringUtils.join(whereClause, " AND ");    }    public String asWhereClauseExact() {        LinkedList<String> whereClause = new LinkedList<>();                if (idIuran > 0)            whereClause.add(idIuranColName + " = '" + idIuran + "'");                if (idClerk > 0)            whereClause.add(idClerkColName + " = '" + idClerk + "'");                if (transactSummaryID > 0)            whereClause.add(idTSummaryColName + " = '" + transactSummaryID + "'");                if (noIndukProfil != null && !noIndukProfil.isEmpty())            whereClause.add(noIndukColName + " = '" + noIndukProfil + "'");                if(level1 != null)            whereClause.add(level1ColName + " = '" + level1 + "'");                if (amount != 0)            whereClause.add(amountColName + " = '" + amount + "'");                if (paymentMethod != null)            whereClause.add(paymentMethodColName + " = '" + paymentMethod + "'");                if (createDate != null){            String wc = createDate.asWhereClause(false);            if(wc != null && !wc.isEmpty())                whereClause.add(createDateColName + " = '" + wc + "'");        }                    if (lastUpdateDate != null){            String wc = lastUpdateDate.asWhereClause(false);            if(wc != null && !wc.isEmpty())                whereClause.add(lastUpdateDateColName + " = '" + wc + "'");        }                if(settled != null)            whereClause.add(settledColName + " = " + (settled? "1" : "0"));                if(piutang != null)            whereClause.add(piutangColName + " = " + (piutang? "1" : "0"));        return whereClause.isEmpty()? "" : StringUtils.join(whereClause, " AND ");    }            //=========================================    public void retrieveIuran() throws SQLException, KasirException{        //idIuran = Control.selectIuran(getTipeIuran(), idIuran.id);    }        public void storeIuran() throws SQLException, KasirException{        //Control.updateIuran(getTipeIuran(), idIuran);    }        public void retrieveClerk() throws SQLException, KasirException{        //idClerk = Clerk.select(idClerk.id);    }        /* caller can also directly updating/inserting the idClerk     */    public void storeClerk() throws SQLException, KasirException{        //Control.updateClerk(idClerk);    }            public void retrieveTransactionSummary() throws SQLException{       // transactSummaryID = DBSR.selectTransactionSummary(Clerk.current.username, Clerk.current.pass, idTSummary);    }    public void storeTransactionSummary() throws SQLException{       // DBSR.updateTransactionSummary(Clerk.current.username, Clerk.current.pass, transactSummaryID);    }            //=========================================    public static <T extends TransactionDetail> T select(T.Tipe tipe, String colName, Number val) throws SQLException, KasirException{        ResultSet rs = DBSR.takeResultSetByNumber(tipe.toString(), colName, 1, val);        return T.fromResultSet(rs, tipe, colName, val);    }    public static <T extends TransactionDetail> T select(T.Tipe tipe, String colName, boolean caseSensitive, String val) throws SQLException, KasirException{        ResultSet rs = DBSR.takeResultSetByString(tipe.toString(), colName, 1, val);        return T.fromResultSet(rs, tipe, colName, false, val);    }    public static <T extends TransactionDetail> T select(T.Tipe tipe, long id) throws SQLException, KasirException{        assert id > 0 : "id < 1";        return select(tipe, idColName, id);    }        public static <T extends TransactionDetail> List<T> selectS(T.Tipe tipe, String colName, boolean caseSensitive, String val) throws SQLException, KasirException{        ResultSet rs = DBSR.takeResultSetByString(tipe.toString(), colName, -1, val);                ArrayList<T> tDetails = new ArrayList<>(DBSR.rowCountRS(rs));        rs.beforeFirst();        while(rs.next())            tDetails.add((T) fromResultSet(rs, tipe));                return tDetails;    }    public static <T extends TransactionDetail> List<T> selectS(T.Tipe tipe, String colName, boolean val) throws SQLException, KasirException{        ResultSet rs = DBSR.takeResultSetByNumber(tipe.toString(), colName, -1, val? 1 : 0);                ArrayList<T> tDetails = new ArrayList<>(DBSR.rowCountRS(rs));        rs.beforeFirst();        while(rs.next())            tDetails.add((T) fromResultSet(rs, tipe));                return tDetails;    }        public static <T extends TransactionDetail> Map<Long,T> selectS(T.Tipe tipe, Set<Long> ids) throws SQLException, KasirException{        ResultSet rs;        Map<Long,T> idTDetail;        if(ids == null){            rs = DBSR.takeResultSetByNumberColl(tipe.toString(), T.idColName, -1, null);            idTDetail = new HashMap<>(DBSR.rowCountRS(rs));            rs.beforeFirst();            while(rs.next()){                T t = T.fromResultSet(rs, tipe);                idTDetail.put(t.id, t);            }        }else{            Set<Long> validId = new HashSet<>();            for(Long id : ids){                if(id > 0)                    validId.add(id);            }            rs = DBSR.takeResultSetByNumberColl(tipe.toString(), idColName, -1, validId);            idTDetail = new HashMap<>(validId.size());            for(Long id : validId){                try{                    idTDetail.put(id, (T) T.fromResultSet(rs, tipe, idColName, id));                }catch(KasirException e){                    idTDetail.put(id, null);                }            }        }        return idTDetail;    }        public static <T extends TransactionDetail> T filterSelect(Tipe tipe, Filter<T> filter) throws SQLException, KasirException{        ResultSet rs = DBSR.takeResultSetByFilter(tipe.toString(), null, 1, filter);        if(rs.next())            return fromResultSet(rs, tipe);        else            throw new KasirException(KasirException.Tipe.ROW_NOT_FOUND, filter);    }    public static <T extends TransactionDetail> Map<Long,T> filterSelectS(T.Tipe tipe, Set<? extends Filter<T>> filters) throws SQLException, KasirException{        ResultSet rs;        if(filters == null)            rs = DBSR.takeResultSetByFilterColl(tipe.toString(), null, -1, null);        else{            //remove null filters / filters with empty asWhereClause, so BAD_RECORD is only detected if filters = null            //arg filters isn't modified            Set<Filter<T>> validFilters = new HashSet<>();            for(Filter<T> filter : filters){                if(filter != null && !"".equals(filter.asWhereClause()))                    validFilters.add(filter);            }            rs = DBSR.takeResultSetByFilterColl(tipe.toString(), null, -1, validFilters);        }                                Map<Long,T> idTDetail = new HashMap<>(DBSR.rowCountRS(rs));        while(rs.next()){            T t = T.fromResultSet(rs, tipe);            idTDetail.put(t.id, t);        }        return idTDetail;    }    public <T extends TransactionDetail> boolean insert(T.Tipe tipe) throws SQLException, KasirException{        return DBSR.insertKasirO(tipe.toString(), idColName, this);    }    public static <T extends TransactionDetail> int insertS(T.Tipe tipe, ArrayList<T> tDetails) throws SQLException, KasirException{        return DBSR.insertKasirOs(tipe.toString(), idColName, tDetails, false);    }    public <T extends TransactionDetail> boolean update(T.Tipe tipe) throws SQLException, KasirException{        return DBSR.updateKasirO(tipe.toString(), idColName, this);    }            public static <T extends TransactionDetail> int updateS(T.Tipe tipe, ArrayList<T> tDetails) throws SQLException, KasirException{        return DBSR.updateKasirOs(tipe.toString(), idColName, tDetails);    }    public <T extends TransactionDetail> boolean updateInsert(T.Tipe tipe) throws SQLException, KasirException{        return DBSR.updateInsertKasirOKeyUnmodifiable(tipe.toString(), idColName, this);    }    public static <T extends TransactionDetail> int updateInsertS(T.Tipe tipe, ArrayList<T> tDetails) throws SQLException, KasirException{        return DBSR.updateInsertKasirOsKeyUnmodifiable(tipe.toString(), idColName, tDetails);    }    public static <T extends TransactionDetail> boolean delete(T.Tipe tipe, long id) throws SQLException, KasirException{        return DBSR.deleteKasirO(tipe.toString(), idColName, id);    }    public static <T extends TransactionDetail> int deleteS(T.Tipe tipe, Set<Long> ids) throws SQLException{        return DBSR.deleteKasirOsByNumber(tipe.toString(), idColName, ids);    }    public static <T extends TransactionDetail> int deleteS(T.Tipe tipe, ArrayList<T> tDetails) throws SQLException{        Set<Long> ids = new HashSet<>(tDetails.size());        for(T tDetail : tDetails)            ids.add(tDetail.id);        return deleteS(tipe, ids);    }}